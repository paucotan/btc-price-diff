{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport axios from 'axios';\nconst CACHE_KEY = 'btc_ticker_data';\nconst RATE_LIMIT_KEY = 'coingecko_rate_limit';\n// Increased cache and refresh intervals to be more conservative with API calls\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\nconst REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes\nconst RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute window for rate limiting\nconst MAX_RETRIES = 1; // Reduced to 1 to be more conservative\nconst BASE_BACKOFF = 3000; // Start with 3 second backoff\n\n// Enhanced fetch with rate limiting, better retry logic, and improved error handling\nconst fetchWithRetry = async (url, options = {}, retries = MAX_RETRIES, backoff = BASE_BACKOFF) => {\n  // Check rate limits before making a request\n  const now = Date.now();\n  const rateLimitData = localStorage.getItem(RATE_LIMIT_KEY);\n  try {\n    // Handle rate limiting\n    if (rateLimitData) {\n      const {\n        timestamp,\n        count\n      } = JSON.parse(rateLimitData);\n      // Reset count if we're in a new rate limit window\n      if (now - timestamp > RATE_LIMIT_WINDOW) {\n        localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n          timestamp: now,\n          count: 1\n        }));\n      } else if (count >= 5) {\n        // Reduced limit to 5 calls per minute to be safe\n        // If we've hit the rate limit, wait until the next window\n        const timeToWait = timestamp + RATE_LIMIT_WINDOW - now;\n        console.warn(`Rate limit reached. Waiting ${Math.ceil(timeToWait / 1000)} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, timeToWait + 1000)); // Add 1s buffer\n        // Reset the counter after waiting\n        localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n          timestamp: Date.now(),\n          count: 1\n        }));\n      } else {\n        // Increment the counter\n        localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n          timestamp,\n          count: count + 1\n        }));\n      }\n    } else {\n      // Initialize rate limit counter\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n        timestamp: now,\n        count: 1\n      }));\n    }\n\n    // Add a small delay between requests to be extra safe\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Make the API request\n    const response = await axios({\n      ...options,\n      url,\n      method: 'GET',\n      timeout: 15000,\n      // Increased to 15 second timeout\n      headers: {\n        'Accept': 'application/json',\n        'Cache-Control': 'no-cache',\n        ...(options.headers || {})\n      }\n    });\n\n    // Log successful API call for debugging\n    console.log(`API call to ${url} successful`);\n    return response;\n  } catch (error) {\n    var _error$response;\n    console.error(`API call failed (${retries} retries left):`, error.message);\n\n    // If we get rate limited, wait longer before retrying\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429) {\n      console.warn('Rate limited by API, waiting before retry...');\n      await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds\n      // Reset rate limit counter\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n        timestamp: Date.now(),\n        count: 0\n      }));\n    }\n    if (retries <= 0) {\n      console.error('Max retries reached, giving up');\n      throw error;\n    }\n\n    // Exponential backoff with jitter\n    const jitter = Math.floor(Math.random() * 1000); // Add up to 1s jitter\n    const delay = backoff + jitter;\n    console.log(`Retrying in ${delay}ms...`);\n    await new Promise(resolve => setTimeout(resolve, delay));\n    return fetchWithRetry(url, options, retries - 1, Math.min(backoff * 2, 30000)); // Cap max backoff at 30s\n  }\n};\nconst useBtcPrice = () => {\n  _s();\n  const [tickerItems, setTickerItems] = useState([{\n    id: 'btc-usd',\n    label: 'BTC/USD',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '$'\n  }, {\n    id: 'btc-eur',\n    label: 'BTC/EUR',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '€'\n  }, {\n    id: 'btc-eth',\n    label: 'BTC/ETH',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: 'Ξ'\n  }, {\n    id: 'gold-usd',\n    label: 'Gold (oz)/USD',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '$'\n  }]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [lastUpdated, setLastUpdated] = useState(null);\n  const isMounted = useRef(true);\n  const getCachedData = () => {\n    const cached = localStorage.getItem(CACHE_KEY);\n    if (!cached) return null;\n    try {\n      const parsed = JSON.parse(cached);\n      if (Date.now() - parsed.lastUpdated < CACHE_DURATION) {\n        return parsed;\n      }\n    } catch (e) {\n      console.error('Error parsing cached data:', e);\n    }\n    return null;\n  };\n  const saveToCache = useCallback(items => {\n    try {\n      const dataToCache = {\n        items,\n        lastUpdated: Date.now()\n      };\n      localStorage.setItem(CACHE_KEY, JSON.stringify(dataToCache));\n    } catch (e) {\n      console.error('Error saving to cache:', e);\n    }\n  }, []);\n  const updateTickerItems = useCallback(newItems => {\n    setTickerItems(prevItems => prevItems.map(item => {\n      const updatedItem = newItems.find(newItem => newItem.id === item.id);\n      return updatedItem ? {\n        ...item,\n        ...updatedItem\n      } : item;\n    }));\n  }, []);\n  const fetchBtcPrice = useCallback(async () => {\n    if (!isMounted.current) return;\n\n    // Don't make a new request if we're already loading\n    if (isLoading) {\n      console.log('Skipping fetch - already loading');\n      return;\n    }\n    try {\n      const cachedData = getCachedData();\n      const now = Date.now();\n\n      // Always use cached data if available, even if we're going to refresh\n      if (cachedData) {\n        console.log('Using cached data from', new Date(cachedData.lastUpdated).toLocaleTimeString());\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n        setIsLoading(false);\n\n        // Skip API call if cache is fresh enough\n        if (now - cachedData.lastUpdated < CACHE_DURATION) {\n          console.log('Cache is fresh, skipping API call');\n          return;\n        }\n      }\n      setIsLoading(true);\n      setError(null);\n\n      // First try with pax-gold, fallback to gold if that fails\n      let response;\n      try {\n        response = await fetchWithRetry('https://api.coingecko.com/api/v3/coins/markets', {\n          params: {\n            vs_currency: 'usd',\n            ids: 'bitcoin,ethereum,pax-gold',\n            price_change_percentage: '24h'\n          }\n        });\n      } catch (err) {\n        console.log('Failed to fetch pax-gold, trying gold...');\n        response = await fetchWithRetry('https://api.coingecko.com/api/v3/coins/markets', {\n          params: {\n            vs_currency: 'usd',\n            ids: 'bitcoin,ethereum,gold',\n            price_change_percentage: '24h'\n          }\n        });\n      }\n      const data = response.data.reduce((acc, coin) => {\n        acc[coin.id] = coin;\n        return acc;\n      }, {});\n      const btcData = data.bitcoin;\n      const ethData = data.ethereum;\n      const goldData = data['pax-gold'] || data.gold;\n      if (!btcData || !ethData || !goldData) {\n        console.error('Incomplete data received from API:', {\n          btcData: !!btcData,\n          ethData: !!ethData,\n          goldData: !!goldData\n        });\n        throw new Error('Incomplete data received from API');\n      }\n      const btcEthPrice = btcData.current_price / ethData.current_price;\n      const btcEthChange24h = (btcData.price_change_percentage_24h - ethData.price_change_percentage_24h) / (1 + ethData.price_change_percentage_24h / 100) || 0;\n\n      // Gold price per ounce in USD (pax-gold is 1:1 with gold price, but we need to check the actual value)\n      // The CoinGecko API returns price per token, and pax-gold is 1 token = 1 troy ounce\n      const goldPricePerOz = goldData.current_price;\n      const updatedItems = [{\n        id: 'btc-usd',\n        label: 'BTC/USD',\n        currentPrice: btcData.current_price,\n        priceChange24h: btcData.price_change_percentage_24h,\n        currencySymbol: '$'\n      }, {\n        id: 'btc-eur',\n        label: 'BTC/EUR',\n        currentPrice: btcData.current_price * 0.9,\n        priceChange24h: btcData.price_change_percentage_24h,\n        currencySymbol: '€'\n      }, {\n        id: 'btc-eth',\n        label: 'BTC/ETH',\n        currentPrice: btcEthPrice,\n        priceChange24h: btcEthChange24h,\n        currencySymbol: 'Ξ'\n      }, {\n        id: 'gold-usd',\n        label: 'Gold (oz)/USD',\n        currentPrice: goldPricePerOz,\n        priceChange24h: goldData.price_change_percentage_24h,\n        currencySymbol: '$'\n      }];\n      updateTickerItems(updatedItems);\n      setLastUpdated(Date.now());\n      saveToCache(updatedItems);\n    } catch (err) {\n      console.error('Error fetching price data:', err);\n      setError('Failed to fetch live data. Using cached data if available.');\n      const cachedData = getCachedData();\n      if (cachedData) {\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n      }\n    } finally {\n      if (isMounted.current) {\n        setIsLoading(false);\n      }\n    }\n  }, [saveToCache, updateTickerItems]);\n  useEffect(() => {\n    isMounted.current = true;\n\n    // Initial fetch\n    console.log('Initial fetch...');\n    fetchBtcPrice().catch(err => {\n      console.error('Error in initial fetch:', err);\n      setError('Failed to load initial data. Using cached data if available.');\n    });\n\n    // Set up refresh interval\n    const intervalId = setInterval(() => {\n      console.log('Refreshing data...');\n      fetchBtcPrice().catch(err => {\n        console.error('Error in refresh:', err);\n        setError('Failed to refresh data. Using cached data if available.');\n      });\n    }, REFRESH_INTERVAL);\n\n    // Cleanup\n    return () => {\n      console.log('Cleaning up...');\n      isMounted.current = false;\n      clearInterval(intervalId);\n    };\n  }, [fetchBtcPrice]);\n  return {\n    items: tickerItems,\n    isLoading,\n    error,\n    lastUpdated,\n    refresh: fetchBtcPrice\n  };\n};\n_s(useBtcPrice, \"sGNDd3pnV81GmJP/2uRQ7KSY8vk=\");\nexport default useBtcPrice;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","axios","CACHE_KEY","RATE_LIMIT_KEY","CACHE_DURATION","REFRESH_INTERVAL","RATE_LIMIT_WINDOW","MAX_RETRIES","BASE_BACKOFF","fetchWithRetry","url","options","retries","backoff","now","Date","rateLimitData","localStorage","getItem","timestamp","count","JSON","parse","setItem","stringify","timeToWait","console","warn","Math","ceil","Promise","resolve","setTimeout","response","method","timeout","headers","log","error","_error$response","message","status","jitter","floor","random","delay","min","useBtcPrice","_s","tickerItems","setTickerItems","id","label","currentPrice","priceChange24h","currencySymbol","isLoading","setIsLoading","setError","lastUpdated","setLastUpdated","isMounted","getCachedData","cached","parsed","e","saveToCache","items","dataToCache","updateTickerItems","newItems","prevItems","map","item","updatedItem","find","newItem","fetchBtcPrice","current","cachedData","toLocaleTimeString","params","vs_currency","ids","price_change_percentage","err","data","reduce","acc","coin","btcData","bitcoin","ethData","ethereum","goldData","gold","Error","btcEthPrice","current_price","btcEthChange24h","price_change_percentage_24h","goldPricePerOz","updatedItems","catch","intervalId","setInterval","clearInterval","refresh"],"sources":["/Users/ocean/code/paucotan/personal_projects/btc-price-diff/src/components/LiveBtcPrice/useBtcPrice.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport axios from 'axios';\n\ninterface TickerItem {\n  id: string;\n  label: string;\n  currentPrice: number | null;\n  priceChange24h: number | null;\n  currencySymbol: string;\n}\n\ninterface CachedData {\n  items: TickerItem[];\n  lastUpdated: number;\n}\n\nconst CACHE_KEY = 'btc_ticker_data';\nconst RATE_LIMIT_KEY = 'coingecko_rate_limit';\n// Increased cache and refresh intervals to be more conservative with API calls\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\nconst REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes\nconst RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute window for rate limiting\nconst MAX_RETRIES = 1; // Reduced to 1 to be more conservative\nconst BASE_BACKOFF = 3000; // Start with 3 second backoff\n\n// Enhanced fetch with rate limiting, better retry logic, and improved error handling\nconst fetchWithRetry = async (\n  url: string, \n  options: Record<string, unknown> = {},\n  retries = MAX_RETRIES,\n  backoff = BASE_BACKOFF\n): Promise<any> => {\n  // Check rate limits before making a request\n  const now = Date.now();\n  const rateLimitData = localStorage.getItem(RATE_LIMIT_KEY);\n  \n  try {\n    // Handle rate limiting\n    if (rateLimitData) {\n      const { timestamp, count } = JSON.parse(rateLimitData);\n      // Reset count if we're in a new rate limit window\n      if (now - timestamp > RATE_LIMIT_WINDOW) {\n        localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp: now, count: 1 }));\n      } else if (count >= 5) { // Reduced limit to 5 calls per minute to be safe\n        // If we've hit the rate limit, wait until the next window\n        const timeToWait = (timestamp + RATE_LIMIT_WINDOW) - now;\n        console.warn(`Rate limit reached. Waiting ${Math.ceil(timeToWait/1000)} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, timeToWait + 1000)); // Add 1s buffer\n        // Reset the counter after waiting\n        localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp: Date.now(), count: 1 }));\n      } else {\n        // Increment the counter\n        localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp, count: count + 1 }));\n      }\n    } else {\n      // Initialize rate limit counter\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp: now, count: 1 }));\n    }\n    \n    // Add a small delay between requests to be extra safe\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Make the API request\n    const response = await axios({\n      ...options,\n      url,\n      method: 'GET',\n      timeout: 15000, // Increased to 15 second timeout\n      headers: {\n        'Accept': 'application/json',\n        'Cache-Control': 'no-cache',\n        ...(options.headers as object || {})\n      }\n    });\n\n    // Log successful API call for debugging\n    console.log(`API call to ${url} successful`);\n    return response;\n  } catch (error: any) {\n    console.error(`API call failed (${retries} retries left):`, error.message);\n    \n    // If we get rate limited, wait longer before retrying\n    if (error.response?.status === 429) {\n      console.warn('Rate limited by API, waiting before retry...');\n      await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds\n      // Reset rate limit counter\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp: Date.now(), count: 0 }));\n    }\n    \n    if (retries <= 0) {\n      console.error('Max retries reached, giving up');\n      throw error;\n    }\n    \n    // Exponential backoff with jitter\n    const jitter = Math.floor(Math.random() * 1000); // Add up to 1s jitter\n    const delay = backoff + jitter;\n    console.log(`Retrying in ${delay}ms...`);\n    \n    await new Promise(resolve => setTimeout(resolve, delay));\n    return fetchWithRetry(url, options, retries - 1, Math.min(backoff * 2, 30000)); // Cap max backoff at 30s\n  }\n};\n\nconst useBtcPrice = () => {\n  const [tickerItems, setTickerItems] = useState<TickerItem[]>([\n    { id: 'btc-usd', label: 'BTC/USD', currentPrice: null, priceChange24h: null, currencySymbol: '$' },\n    { id: 'btc-eur', label: 'BTC/EUR', currentPrice: null, priceChange24h: null, currencySymbol: '€' },\n    { id: 'btc-eth', label: 'BTC/ETH', currentPrice: null, priceChange24h: null, currencySymbol: 'Ξ' },\n    { id: 'gold-usd', label: 'Gold (oz)/USD', currentPrice: null, priceChange24h: null, currencySymbol: '$' },\n  ]);\n  \n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [lastUpdated, setLastUpdated] = useState<number | null>(null);\n  const isMounted = useRef(true);\n\n  const getCachedData = (): CachedData | null => {\n    const cached = localStorage.getItem(CACHE_KEY);\n    if (!cached) return null;\n    \n    try {\n      const parsed = JSON.parse(cached);\n      if (Date.now() - parsed.lastUpdated < CACHE_DURATION) {\n        return parsed;\n      }\n    } catch (e) {\n      console.error('Error parsing cached data:', e);\n    }\n    return null;\n  };\n\n  const saveToCache = useCallback((items: TickerItem[]) => {\n    try {\n      const dataToCache = {\n        items,\n        lastUpdated: Date.now(),\n      };\n      localStorage.setItem(CACHE_KEY, JSON.stringify(dataToCache));\n    } catch (e) {\n      console.error('Error saving to cache:', e);\n    }\n  }, []);\n\n  const updateTickerItems = useCallback((newItems: TickerItem[]) => {\n    setTickerItems(prevItems => \n      prevItems.map(item => {\n        const updatedItem = newItems.find(newItem => newItem.id === item.id);\n        return updatedItem ? { ...item, ...updatedItem } : item;\n      })\n    );\n  }, []);\n\n  const fetchBtcPrice = useCallback(async () => {\n    if (!isMounted.current) return;\n    \n    // Don't make a new request if we're already loading\n    if (isLoading) {\n      console.log('Skipping fetch - already loading');\n      return;\n    }\n    \n    try {\n      const cachedData = getCachedData();\n      const now = Date.now();\n      \n      // Always use cached data if available, even if we're going to refresh\n      if (cachedData) {\n        console.log('Using cached data from', new Date(cachedData.lastUpdated).toLocaleTimeString());\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n        setIsLoading(false);\n        \n        // Skip API call if cache is fresh enough\n        if (now - cachedData.lastUpdated < CACHE_DURATION) {\n          console.log('Cache is fresh, skipping API call');\n          return;\n        }\n      }\n      \n      setIsLoading(true);\n      setError(null);\n      \n      // First try with pax-gold, fallback to gold if that fails\n      let response;\n      try {\n        response = await fetchWithRetry(\n          'https://api.coingecko.com/api/v3/coins/markets',\n          {\n            params: {\n              vs_currency: 'usd',\n              ids: 'bitcoin,ethereum,pax-gold',\n              price_change_percentage: '24h',\n            },\n          }\n        );\n      } catch (err) {\n        console.log('Failed to fetch pax-gold, trying gold...');\n        response = await fetchWithRetry(\n          'https://api.coingecko.com/api/v3/coins/markets',\n          {\n            params: {\n              vs_currency: 'usd',\n              ids: 'bitcoin,ethereum,gold',\n              price_change_percentage: '24h',\n            },\n          }\n        );\n      }\n      \n      const data = response.data.reduce((acc: any, coin: any) => {\n        acc[coin.id] = coin;\n        return acc;\n      }, {});\n      \n      const btcData = data.bitcoin;\n      const ethData = data.ethereum;\n      const goldData = data['pax-gold'] || data.gold;\n      \n      if (!btcData || !ethData || !goldData) {\n        console.error('Incomplete data received from API:', { btcData: !!btcData, ethData: !!ethData, goldData: !!goldData });\n        throw new Error('Incomplete data received from API');\n      }\n      \n      const btcEthPrice = btcData.current_price / ethData.current_price;\n      const btcEthChange24h = ((btcData.price_change_percentage_24h - ethData.price_change_percentage_24h) / \n        (1 + ethData.price_change_percentage_24h / 100)) || 0;\n      \n      // Gold price per ounce in USD (pax-gold is 1:1 with gold price, but we need to check the actual value)\n      // The CoinGecko API returns price per token, and pax-gold is 1 token = 1 troy ounce\n      const goldPricePerOz = goldData.current_price;\n      \n      const updatedItems: TickerItem[] = [\n        { \n          id: 'btc-usd', \n          label: 'BTC/USD', \n          currentPrice: btcData.current_price, \n          priceChange24h: btcData.price_change_percentage_24h, \n          currencySymbol: '$' \n        },\n        { \n          id: 'btc-eur', \n          label: 'BTC/EUR', \n          currentPrice: btcData.current_price * 0.9,\n          priceChange24h: btcData.price_change_percentage_24h, \n          currencySymbol: '€' \n        },\n        { \n          id: 'btc-eth', \n          label: 'BTC/ETH', \n          currentPrice: btcEthPrice, \n          priceChange24h: btcEthChange24h, \n          currencySymbol: 'Ξ' \n        },\n        { \n          id: 'gold-usd', \n          label: 'Gold (oz)/USD', \n          currentPrice: goldPricePerOz, \n          priceChange24h: goldData.price_change_percentage_24h, \n          currencySymbol: '$' \n        },\n      ];\n      \n      updateTickerItems(updatedItems);\n      setLastUpdated(Date.now());\n      saveToCache(updatedItems);\n      \n    } catch (err) {\n      console.error('Error fetching price data:', err);\n      setError('Failed to fetch live data. Using cached data if available.');\n      const cachedData = getCachedData();\n      if (cachedData) {\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n      }\n    } finally {\n      if (isMounted.current) {\n        setIsLoading(false);\n      }\n    }\n  }, [saveToCache, updateTickerItems]);\n\n  useEffect(() => {\n    isMounted.current = true;\n    \n    // Initial fetch\n    console.log('Initial fetch...');\n    fetchBtcPrice().catch(err => {\n      console.error('Error in initial fetch:', err);\n      setError('Failed to load initial data. Using cached data if available.');\n    });\n    \n    // Set up refresh interval\n    const intervalId = setInterval(() => {\n      console.log('Refreshing data...');\n      fetchBtcPrice().catch(err => {\n        console.error('Error in refresh:', err);\n        setError('Failed to refresh data. Using cached data if available.');\n      });\n    }, REFRESH_INTERVAL);\n    \n    // Cleanup\n    return () => {\n      console.log('Cleaning up...');\n      isMounted.current = false;\n      clearInterval(intervalId);\n    };\n  }, [fetchBtcPrice]);\n\n  return {\n    items: tickerItems,\n    isLoading,\n    error,\n    lastUpdated,\n    refresh: fetchBtcPrice,\n  };\n};\n\nexport default useBtcPrice;\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,EAAEC,MAAM,QAAQ,OAAO;AAChE,OAAOC,KAAK,MAAM,OAAO;AAezB,MAAMC,SAAS,GAAG,iBAAiB;AACnC,MAAMC,cAAc,GAAG,sBAAsB;AAC7C;AACA,MAAMC,cAAc,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AACtC,MAAMC,gBAAgB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AACxC,MAAMC,iBAAiB,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AACrC,MAAMC,WAAW,GAAG,CAAC,CAAC,CAAC;AACvB,MAAMC,YAAY,GAAG,IAAI,CAAC,CAAC;;AAE3B;AACA,MAAMC,cAAc,GAAG,MAAAA,CACrBC,GAAW,EACXC,OAAgC,GAAG,CAAC,CAAC,EACrCC,OAAO,GAAGL,WAAW,EACrBM,OAAO,GAAGL,YAAY,KACL;EACjB;EACA,MAAMM,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;EACtB,MAAME,aAAa,GAAGC,YAAY,CAACC,OAAO,CAACf,cAAc,CAAC;EAE1D,IAAI;IACF;IACA,IAAIa,aAAa,EAAE;MACjB,MAAM;QAAEG,SAAS;QAAEC;MAAM,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACN,aAAa,CAAC;MACtD;MACA,IAAIF,GAAG,GAAGK,SAAS,GAAGb,iBAAiB,EAAE;QACvCW,YAAY,CAACM,OAAO,CAACpB,cAAc,EAAEkB,IAAI,CAACG,SAAS,CAAC;UAAEL,SAAS,EAAEL,GAAG;UAAEM,KAAK,EAAE;QAAE,CAAC,CAAC,CAAC;MACpF,CAAC,MAAM,IAAIA,KAAK,IAAI,CAAC,EAAE;QAAE;QACvB;QACA,MAAMK,UAAU,GAAIN,SAAS,GAAGb,iBAAiB,GAAIQ,GAAG;QACxDY,OAAO,CAACC,IAAI,CAAC,+BAA+BC,IAAI,CAACC,IAAI,CAACJ,UAAU,GAAC,IAAI,CAAC,aAAa,CAAC;QACpF,MAAM,IAAIK,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEN,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACtE;QACAR,YAAY,CAACM,OAAO,CAACpB,cAAc,EAAEkB,IAAI,CAACG,SAAS,CAAC;UAAEL,SAAS,EAAEJ,IAAI,CAACD,GAAG,CAAC,CAAC;UAAEM,KAAK,EAAE;QAAE,CAAC,CAAC,CAAC;MAC3F,CAAC,MAAM;QACL;QACAH,YAAY,CAACM,OAAO,CAACpB,cAAc,EAAEkB,IAAI,CAACG,SAAS,CAAC;UAAEL,SAAS;UAAEC,KAAK,EAAEA,KAAK,GAAG;QAAE,CAAC,CAAC,CAAC;MACvF;IACF,CAAC,MAAM;MACL;MACAH,YAAY,CAACM,OAAO,CAACpB,cAAc,EAAEkB,IAAI,CAACG,SAAS,CAAC;QAAEL,SAAS,EAAEL,GAAG;QAAEM,KAAK,EAAE;MAAE,CAAC,CAAC,CAAC;IACpF;;IAEA;IACA,MAAM,IAAIU,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;;IAEtD;IACA,MAAME,QAAQ,GAAG,MAAMhC,KAAK,CAAC;MAC3B,GAAGU,OAAO;MACVD,GAAG;MACHwB,MAAM,EAAE,KAAK;MACbC,OAAO,EAAE,KAAK;MAAE;MAChBC,OAAO,EAAE;QACP,QAAQ,EAAE,kBAAkB;QAC5B,eAAe,EAAE,UAAU;QAC3B,IAAIzB,OAAO,CAACyB,OAAO,IAAc,CAAC,CAAC;MACrC;IACF,CAAC,CAAC;;IAEF;IACAV,OAAO,CAACW,GAAG,CAAC,eAAe3B,GAAG,aAAa,CAAC;IAC5C,OAAOuB,QAAQ;EACjB,CAAC,CAAC,OAAOK,KAAU,EAAE;IAAA,IAAAC,eAAA;IACnBb,OAAO,CAACY,KAAK,CAAC,oBAAoB1B,OAAO,iBAAiB,EAAE0B,KAAK,CAACE,OAAO,CAAC;;IAE1E;IACA,IAAI,EAAAD,eAAA,GAAAD,KAAK,CAACL,QAAQ,cAAAM,eAAA,uBAAdA,eAAA,CAAgBE,MAAM,MAAK,GAAG,EAAE;MAClCf,OAAO,CAACC,IAAI,CAAC,8CAA8C,CAAC;MAC5D,MAAM,IAAIG,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;MAC1D;MACAd,YAAY,CAACM,OAAO,CAACpB,cAAc,EAAEkB,IAAI,CAACG,SAAS,CAAC;QAAEL,SAAS,EAAEJ,IAAI,CAACD,GAAG,CAAC,CAAC;QAAEM,KAAK,EAAE;MAAE,CAAC,CAAC,CAAC;IAC3F;IAEA,IAAIR,OAAO,IAAI,CAAC,EAAE;MAChBc,OAAO,CAACY,KAAK,CAAC,gCAAgC,CAAC;MAC/C,MAAMA,KAAK;IACb;;IAEA;IACA,MAAMI,MAAM,GAAGd,IAAI,CAACe,KAAK,CAACf,IAAI,CAACgB,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACjD,MAAMC,KAAK,GAAGhC,OAAO,GAAG6B,MAAM;IAC9BhB,OAAO,CAACW,GAAG,CAAC,eAAeQ,KAAK,OAAO,CAAC;IAExC,MAAM,IAAIf,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEc,KAAK,CAAC,CAAC;IACxD,OAAOpC,cAAc,CAACC,GAAG,EAAEC,OAAO,EAAEC,OAAO,GAAG,CAAC,EAAEgB,IAAI,CAACkB,GAAG,CAACjC,OAAO,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;EAClF;AACF,CAAC;AAED,MAAMkC,WAAW,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACxB,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGrD,QAAQ,CAAe,CAC3D;IAAEsD,EAAE,EAAE,SAAS;IAAEC,KAAK,EAAE,SAAS;IAAEC,YAAY,EAAE,IAAI;IAAEC,cAAc,EAAE,IAAI;IAAEC,cAAc,EAAE;EAAI,CAAC,EAClG;IAAEJ,EAAE,EAAE,SAAS;IAAEC,KAAK,EAAE,SAAS;IAAEC,YAAY,EAAE,IAAI;IAAEC,cAAc,EAAE,IAAI;IAAEC,cAAc,EAAE;EAAI,CAAC,EAClG;IAAEJ,EAAE,EAAE,SAAS;IAAEC,KAAK,EAAE,SAAS;IAAEC,YAAY,EAAE,IAAI;IAAEC,cAAc,EAAE,IAAI;IAAEC,cAAc,EAAE;EAAI,CAAC,EAClG;IAAEJ,EAAE,EAAE,UAAU;IAAEC,KAAK,EAAE,eAAe;IAAEC,YAAY,EAAE,IAAI;IAAEC,cAAc,EAAE,IAAI;IAAEC,cAAc,EAAE;EAAI,CAAC,CAC1G,CAAC;EAEF,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAG5D,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACyC,KAAK,EAAEoB,QAAQ,CAAC,GAAG7D,QAAQ,CAAgB,IAAI,CAAC;EACvD,MAAM,CAAC8D,WAAW,EAAEC,cAAc,CAAC,GAAG/D,QAAQ,CAAgB,IAAI,CAAC;EACnE,MAAMgE,SAAS,GAAG7D,MAAM,CAAC,IAAI,CAAC;EAE9B,MAAM8D,aAAa,GAAGA,CAAA,KAAyB;IAC7C,MAAMC,MAAM,GAAG9C,YAAY,CAACC,OAAO,CAAChB,SAAS,CAAC;IAC9C,IAAI,CAAC6D,MAAM,EAAE,OAAO,IAAI;IAExB,IAAI;MACF,MAAMC,MAAM,GAAG3C,IAAI,CAACC,KAAK,CAACyC,MAAM,CAAC;MACjC,IAAIhD,IAAI,CAACD,GAAG,CAAC,CAAC,GAAGkD,MAAM,CAACL,WAAW,GAAGvD,cAAc,EAAE;QACpD,OAAO4D,MAAM;MACf;IACF,CAAC,CAAC,OAAOC,CAAC,EAAE;MACVvC,OAAO,CAACY,KAAK,CAAC,4BAA4B,EAAE2B,CAAC,CAAC;IAChD;IACA,OAAO,IAAI;EACb,CAAC;EAED,MAAMC,WAAW,GAAGnE,WAAW,CAAEoE,KAAmB,IAAK;IACvD,IAAI;MACF,MAAMC,WAAW,GAAG;QAClBD,KAAK;QACLR,WAAW,EAAE5C,IAAI,CAACD,GAAG,CAAC;MACxB,CAAC;MACDG,YAAY,CAACM,OAAO,CAACrB,SAAS,EAAEmB,IAAI,CAACG,SAAS,CAAC4C,WAAW,CAAC,CAAC;IAC9D,CAAC,CAAC,OAAOH,CAAC,EAAE;MACVvC,OAAO,CAACY,KAAK,CAAC,wBAAwB,EAAE2B,CAAC,CAAC;IAC5C;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMI,iBAAiB,GAAGtE,WAAW,CAAEuE,QAAsB,IAAK;IAChEpB,cAAc,CAACqB,SAAS,IACtBA,SAAS,CAACC,GAAG,CAACC,IAAI,IAAI;MACpB,MAAMC,WAAW,GAAGJ,QAAQ,CAACK,IAAI,CAACC,OAAO,IAAIA,OAAO,CAACzB,EAAE,KAAKsB,IAAI,CAACtB,EAAE,CAAC;MACpE,OAAOuB,WAAW,GAAG;QAAE,GAAGD,IAAI;QAAE,GAAGC;MAAY,CAAC,GAAGD,IAAI;IACzD,CAAC,CACH,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMI,aAAa,GAAG9E,WAAW,CAAC,YAAY;IAC5C,IAAI,CAAC8D,SAAS,CAACiB,OAAO,EAAE;;IAExB;IACA,IAAItB,SAAS,EAAE;MACb9B,OAAO,CAACW,GAAG,CAAC,kCAAkC,CAAC;MAC/C;IACF;IAEA,IAAI;MACF,MAAM0C,UAAU,GAAGjB,aAAa,CAAC,CAAC;MAClC,MAAMhD,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;;MAEtB;MACA,IAAIiE,UAAU,EAAE;QACdrD,OAAO,CAACW,GAAG,CAAC,wBAAwB,EAAE,IAAItB,IAAI,CAACgE,UAAU,CAACpB,WAAW,CAAC,CAACqB,kBAAkB,CAAC,CAAC,CAAC;QAC5FX,iBAAiB,CAACU,UAAU,CAACZ,KAAK,CAAC;QACnCP,cAAc,CAACmB,UAAU,CAACpB,WAAW,CAAC;QACtCF,YAAY,CAAC,KAAK,CAAC;;QAEnB;QACA,IAAI3C,GAAG,GAAGiE,UAAU,CAACpB,WAAW,GAAGvD,cAAc,EAAE;UACjDsB,OAAO,CAACW,GAAG,CAAC,mCAAmC,CAAC;UAChD;QACF;MACF;MAEAoB,YAAY,CAAC,IAAI,CAAC;MAClBC,QAAQ,CAAC,IAAI,CAAC;;MAEd;MACA,IAAIzB,QAAQ;MACZ,IAAI;QACFA,QAAQ,GAAG,MAAMxB,cAAc,CAC7B,gDAAgD,EAChD;UACEwE,MAAM,EAAE;YACNC,WAAW,EAAE,KAAK;YAClBC,GAAG,EAAE,2BAA2B;YAChCC,uBAAuB,EAAE;UAC3B;QACF,CACF,CAAC;MACH,CAAC,CAAC,OAAOC,GAAG,EAAE;QACZ3D,OAAO,CAACW,GAAG,CAAC,0CAA0C,CAAC;QACvDJ,QAAQ,GAAG,MAAMxB,cAAc,CAC7B,gDAAgD,EAChD;UACEwE,MAAM,EAAE;YACNC,WAAW,EAAE,KAAK;YAClBC,GAAG,EAAE,uBAAuB;YAC5BC,uBAAuB,EAAE;UAC3B;QACF,CACF,CAAC;MACH;MAEA,MAAME,IAAI,GAAGrD,QAAQ,CAACqD,IAAI,CAACC,MAAM,CAAC,CAACC,GAAQ,EAAEC,IAAS,KAAK;QACzDD,GAAG,CAACC,IAAI,CAACtC,EAAE,CAAC,GAAGsC,IAAI;QACnB,OAAOD,GAAG;MACZ,CAAC,EAAE,CAAC,CAAC,CAAC;MAEN,MAAME,OAAO,GAAGJ,IAAI,CAACK,OAAO;MAC5B,MAAMC,OAAO,GAAGN,IAAI,CAACO,QAAQ;MAC7B,MAAMC,QAAQ,GAAGR,IAAI,CAAC,UAAU,CAAC,IAAIA,IAAI,CAACS,IAAI;MAE9C,IAAI,CAACL,OAAO,IAAI,CAACE,OAAO,IAAI,CAACE,QAAQ,EAAE;QACrCpE,OAAO,CAACY,KAAK,CAAC,oCAAoC,EAAE;UAAEoD,OAAO,EAAE,CAAC,CAACA,OAAO;UAAEE,OAAO,EAAE,CAAC,CAACA,OAAO;UAAEE,QAAQ,EAAE,CAAC,CAACA;QAAS,CAAC,CAAC;QACrH,MAAM,IAAIE,KAAK,CAAC,mCAAmC,CAAC;MACtD;MAEA,MAAMC,WAAW,GAAGP,OAAO,CAACQ,aAAa,GAAGN,OAAO,CAACM,aAAa;MACjE,MAAMC,eAAe,GAAI,CAACT,OAAO,CAACU,2BAA2B,GAAGR,OAAO,CAACQ,2BAA2B,KAChG,CAAC,GAAGR,OAAO,CAACQ,2BAA2B,GAAG,GAAG,CAAC,IAAK,CAAC;;MAEvD;MACA;MACA,MAAMC,cAAc,GAAGP,QAAQ,CAACI,aAAa;MAE7C,MAAMI,YAA0B,GAAG,CACjC;QACEnD,EAAE,EAAE,SAAS;QACbC,KAAK,EAAE,SAAS;QAChBC,YAAY,EAAEqC,OAAO,CAACQ,aAAa;QACnC5C,cAAc,EAAEoC,OAAO,CAACU,2BAA2B;QACnD7C,cAAc,EAAE;MAClB,CAAC,EACD;QACEJ,EAAE,EAAE,SAAS;QACbC,KAAK,EAAE,SAAS;QAChBC,YAAY,EAAEqC,OAAO,CAACQ,aAAa,GAAG,GAAG;QACzC5C,cAAc,EAAEoC,OAAO,CAACU,2BAA2B;QACnD7C,cAAc,EAAE;MAClB,CAAC,EACD;QACEJ,EAAE,EAAE,SAAS;QACbC,KAAK,EAAE,SAAS;QAChBC,YAAY,EAAE4C,WAAW;QACzB3C,cAAc,EAAE6C,eAAe;QAC/B5C,cAAc,EAAE;MAClB,CAAC,EACD;QACEJ,EAAE,EAAE,UAAU;QACdC,KAAK,EAAE,eAAe;QACtBC,YAAY,EAAEgD,cAAc;QAC5B/C,cAAc,EAAEwC,QAAQ,CAACM,2BAA2B;QACpD7C,cAAc,EAAE;MAClB,CAAC,CACF;MAEDc,iBAAiB,CAACiC,YAAY,CAAC;MAC/B1C,cAAc,CAAC7C,IAAI,CAACD,GAAG,CAAC,CAAC,CAAC;MAC1BoD,WAAW,CAACoC,YAAY,CAAC;IAE3B,CAAC,CAAC,OAAOjB,GAAG,EAAE;MACZ3D,OAAO,CAACY,KAAK,CAAC,4BAA4B,EAAE+C,GAAG,CAAC;MAChD3B,QAAQ,CAAC,4DAA4D,CAAC;MACtE,MAAMqB,UAAU,GAAGjB,aAAa,CAAC,CAAC;MAClC,IAAIiB,UAAU,EAAE;QACdV,iBAAiB,CAACU,UAAU,CAACZ,KAAK,CAAC;QACnCP,cAAc,CAACmB,UAAU,CAACpB,WAAW,CAAC;MACxC;IACF,CAAC,SAAS;MACR,IAAIE,SAAS,CAACiB,OAAO,EAAE;QACrBrB,YAAY,CAAC,KAAK,CAAC;MACrB;IACF;EACF,CAAC,EAAE,CAACS,WAAW,EAAEG,iBAAiB,CAAC,CAAC;EAEpCvE,SAAS,CAAC,MAAM;IACd+D,SAAS,CAACiB,OAAO,GAAG,IAAI;;IAExB;IACApD,OAAO,CAACW,GAAG,CAAC,kBAAkB,CAAC;IAC/BwC,aAAa,CAAC,CAAC,CAAC0B,KAAK,CAAClB,GAAG,IAAI;MAC3B3D,OAAO,CAACY,KAAK,CAAC,yBAAyB,EAAE+C,GAAG,CAAC;MAC7C3B,QAAQ,CAAC,8DAA8D,CAAC;IAC1E,CAAC,CAAC;;IAEF;IACA,MAAM8C,UAAU,GAAGC,WAAW,CAAC,MAAM;MACnC/E,OAAO,CAACW,GAAG,CAAC,oBAAoB,CAAC;MACjCwC,aAAa,CAAC,CAAC,CAAC0B,KAAK,CAAClB,GAAG,IAAI;QAC3B3D,OAAO,CAACY,KAAK,CAAC,mBAAmB,EAAE+C,GAAG,CAAC;QACvC3B,QAAQ,CAAC,yDAAyD,CAAC;MACrE,CAAC,CAAC;IACJ,CAAC,EAAErD,gBAAgB,CAAC;;IAEpB;IACA,OAAO,MAAM;MACXqB,OAAO,CAACW,GAAG,CAAC,gBAAgB,CAAC;MAC7BwB,SAAS,CAACiB,OAAO,GAAG,KAAK;MACzB4B,aAAa,CAACF,UAAU,CAAC;IAC3B,CAAC;EACH,CAAC,EAAE,CAAC3B,aAAa,CAAC,CAAC;EAEnB,OAAO;IACLV,KAAK,EAAElB,WAAW;IAClBO,SAAS;IACTlB,KAAK;IACLqB,WAAW;IACXgD,OAAO,EAAE9B;EACX,CAAC;AACH,CAAC;AAAC7B,EAAA,CApNID,WAAW;AAsNjB,eAAeA,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}