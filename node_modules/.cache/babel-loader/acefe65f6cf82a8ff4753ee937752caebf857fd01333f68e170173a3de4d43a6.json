{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport axios from 'axios';\n// Cache for storing API responses\nconst CACHE_KEY = 'btcPriceData';\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache\n\n// Helper functions outside the hook\nconst getCachedData = () => {\n  const cached = localStorage.getItem(CACHE_KEY);\n  if (!cached) return null;\n  try {\n    const {\n      data,\n      timestamp\n    } = JSON.parse(cached);\n    // Return cached data if it's still fresh\n    if (Date.now() - timestamp < CACHE_DURATION) {\n      return data;\n    }\n  } catch (e) {\n    console.error('Error reading cache:', e);\n  }\n  return null;\n};\nconst saveToCache = data => {\n  try {\n    localStorage.setItem(CACHE_KEY, JSON.stringify({\n      data,\n      timestamp: Date.now()\n    }));\n  } catch (e) {\n    console.error('Error saving to cache:', e);\n  }\n};\nconst useBtcPrice = (refreshInterval = 60000) => {\n  _s();\n  const [tickerItems, setTickerItems] = useState([{\n    id: 'btc-usd',\n    label: 'BTC/USD',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '$'\n  }, {\n    id: 'btc-eur',\n    label: 'BTC/EUR',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '€'\n  }, {\n    id: 'btc-eth',\n    label: 'BTC/ETH',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: 'Ξ'\n  }, {\n    id: 'btc-gold',\n    label: 'Gold (oz)',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: 'oz'\n  }]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [lastUpdated, setLastUpdated] = useState(null);\n\n  // Memoized function to update ticker items\n  const updateTickerItems = useCallback(newItems => {\n    setTickerItems(prevItems => prevItems.map(item => {\n      const updatedItem = newItems.find(newItem => newItem.id === item.id);\n      return updatedItem ? {\n        ...item,\n        ...updatedItem\n      } : item;\n    }));\n  }, []);\n\n  // Memoized fetch function with all required dependencies\n  const fetchBtcPrice = useCallback(async () => {\n    const fetchAndUpdate = async () => {\n      try {\n        // Check cache first\n        const cachedData = getCachedData();\n        if (cachedData) {\n          updateTickerItems(cachedData.items);\n          setLastUpdated(cachedData.lastUpdated);\n          setIsLoading(false);\n          setError(null);\n          return; // Use cached data if available\n        }\n        setIsLoading(true);\n        setError(null);\n\n        // Fetch BTC prices with rate limit handling\n        const [btcResponse, ethResponse, goldResponse] = await Promise.all([\n        // BTC/USD and BTC/EUR\n        axios.get('https://api.coingecko.com/api/v3/simple/price', {\n          params: {\n            ids: 'bitcoin',\n            vs_currencies: 'usd,eur',\n            include_24hr_change: true\n          }\n        }),\n        // ETH/USD for BTC/ETH conversion\n        axios.get('https://api.coingecko.com/api/v3/simple/price', {\n          params: {\n            ids: 'ethereum',\n            vs_currencies: 'usd',\n            include_24hr_change: true\n          }\n        }),\n        // Gold price in USD (approximate)\n        axios.get('https://api.coingecko.com/api/v3/simple/price', {\n          params: {\n            ids: 'pax-gold',\n            vs_currencies: 'usd'\n          }\n        })]);\n        const btcData = btcResponse.data.bitcoin;\n        const ethData = ethResponse.data.ethereum;\n        const goldData = goldResponse.data['pax-gold'];\n\n        // Calculate BTC/ETH price\n        const btcEthPrice = btcData.usd / ethData.usd;\n        const btcEthChange24h = (btcData.usd_24h_change - ethData.usd_24h_change) / (1 + ethData.usd_24h_change / 100) || 0;\n\n        // Calculate BTC/Gold price (gold price is per gram, converting to oz)\n        const goldPricePerOz = goldData.usd * 31.1; // 1 oz = 31.1 grams\n        const btcGoldPrice = btcData.usd / goldPricePerOz;\n\n        // Create updated items\n        const updatedItems = tickerItems.map(item => {\n          switch (item.id) {\n            case 'btc-usd':\n              return {\n                ...item,\n                currentPrice: btcData.usd,\n                priceChange24h: btcData.usd_24h_change\n              };\n            case 'btc-eur':\n              return {\n                ...item,\n                currentPrice: btcData.eur,\n                priceChange24h: btcData.eur_24h_change\n              };\n            case 'btc-eth':\n              return {\n                ...item,\n                currentPrice: btcEthPrice,\n                priceChange24h: btcEthChange24h\n              };\n            case 'btc-gold':\n              return {\n                ...item,\n                currentPrice: btcGoldPrice,\n                priceChange24h: btcData.usd_24h_change\n              };\n            default:\n              return item;\n          }\n        });\n\n        // Update state\n        updateTickerItems(updatedItems);\n        const newLastUpdated = Date.now();\n        setLastUpdated(newLastUpdated);\n\n        // Save to cache\n        saveToCache({\n          items: updatedItems,\n          isLoading: false,\n          error: null,\n          lastUpdated: newLastUpdated\n        });\n      } catch (err) {\n        console.error('Error fetching price data:', err);\n        setError('Failed to fetch price data');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    await fetchAndUpdate();\n  }, [tickerItems, updateTickerItems]);\n  useEffect(() => {\n    // Initial fetch\n    fetchBtcPrice();\n\n    // Set up effect for fetching data\n    const intervalId = setInterval(fetchBtcPrice, refreshInterval);\n\n    // Clean up interval on component unmount\n    return () => clearInterval(intervalId);\n  }, [refreshInterval, fetchBtcPrice]);\n  return {\n    items: tickerItems,\n    isLoading,\n    error,\n    lastUpdated\n  };\n};\n_s(useBtcPrice, \"Fg0dlMKw9/HBganJGOJy5QzymQw=\");\nexport default useBtcPrice;","map":{"version":3,"names":["useState","useEffect","useCallback","axios","CACHE_KEY","CACHE_DURATION","getCachedData","cached","localStorage","getItem","data","timestamp","JSON","parse","Date","now","e","console","error","saveToCache","setItem","stringify","useBtcPrice","refreshInterval","_s","tickerItems","setTickerItems","id","label","currentPrice","priceChange24h","currencySymbol","isLoading","setIsLoading","setError","lastUpdated","setLastUpdated","updateTickerItems","newItems","prevItems","map","item","updatedItem","find","newItem","fetchBtcPrice","fetchAndUpdate","cachedData","items","btcResponse","ethResponse","goldResponse","Promise","all","get","params","ids","vs_currencies","include_24hr_change","btcData","bitcoin","ethData","ethereum","goldData","btcEthPrice","usd","btcEthChange24h","usd_24h_change","goldPricePerOz","btcGoldPrice","updatedItems","eur","eur_24h_change","newLastUpdated","err","intervalId","setInterval","clearInterval"],"sources":["/Users/ocean/code/paucotan/personal_projects/btc-price-diff/src/components/LiveBtcPrice/useBtcPrice.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport axios from 'axios';\n\nexport interface TickerItem {\n  id: string;\n  label: string;\n  currentPrice: number | null;\n  priceChange24h: number | null;\n  currencySymbol?: string;\n}\n\ninterface BtcPriceData {\n  items: TickerItem[];\n  isLoading: boolean;\n  error: string | null;\n  lastUpdated: number | null;\n}\n\n// Cache for storing API responses\nconst CACHE_KEY = 'btcPriceData';\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache\n\n// Helper functions outside the hook\nconst getCachedData = (): BtcPriceData | null => {\n  const cached = localStorage.getItem(CACHE_KEY);\n  if (!cached) return null;\n  \n  try {\n    const { data, timestamp } = JSON.parse(cached);\n    // Return cached data if it's still fresh\n    if (Date.now() - timestamp < CACHE_DURATION) {\n      return data;\n    }\n  } catch (e) {\n    console.error('Error reading cache:', e);\n  }\n  return null;\n};\n\nconst saveToCache = (data: BtcPriceData) => {\n  try {\n    localStorage.setItem(CACHE_KEY, JSON.stringify({\n      data,\n      timestamp: Date.now()\n    }));\n  } catch (e) {\n    console.error('Error saving to cache:', e);\n  }\n};\n\nconst useBtcPrice = (refreshInterval = 60000): BtcPriceData => {\n  const [tickerItems, setTickerItems] = useState<TickerItem[]>([\n    { id: 'btc-usd', label: 'BTC/USD', currentPrice: null, priceChange24h: null, currencySymbol: '$' },\n    { id: 'btc-eur', label: 'BTC/EUR', currentPrice: null, priceChange24h: null, currencySymbol: '€' },\n    { id: 'btc-eth', label: 'BTC/ETH', currentPrice: null, priceChange24h: null, currencySymbol: 'Ξ' },\n    { id: 'btc-gold', label: 'Gold (oz)', currentPrice: null, priceChange24h: null, currencySymbol: 'oz' },\n  ]);\n  \n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [lastUpdated, setLastUpdated] = useState<number | null>(null);\n  \n  // Memoized function to update ticker items\n  const updateTickerItems = useCallback((newItems: TickerItem[]) => {\n    setTickerItems(prevItems => \n      prevItems.map(item => {\n        const updatedItem = newItems.find(newItem => newItem.id === item.id);\n        return updatedItem ? { ...item, ...updatedItem } : item;\n      })\n    );\n  }, []);\n  \n  // Memoized fetch function with all required dependencies\n  const fetchBtcPrice = useCallback(async (): Promise<void> => {\n    const fetchAndUpdate = async () => {\n      try {\n        // Check cache first\n        const cachedData = getCachedData();\n        if (cachedData) {\n          updateTickerItems(cachedData.items);\n          setLastUpdated(cachedData.lastUpdated);\n          setIsLoading(false);\n          setError(null);\n          return; // Use cached data if available\n        }\n\n        setIsLoading(true);\n        setError(null);\n        \n        // Fetch BTC prices with rate limit handling\n        const [btcResponse, ethResponse, goldResponse] = await Promise.all([\n          // BTC/USD and BTC/EUR\n          axios.get('https://api.coingecko.com/api/v3/simple/price', {\n            params: {\n              ids: 'bitcoin',\n              vs_currencies: 'usd,eur',\n              include_24hr_change: true,\n            },\n          }),\n          // ETH/USD for BTC/ETH conversion\n          axios.get('https://api.coingecko.com/api/v3/simple/price', {\n            params: {\n              ids: 'ethereum',\n              vs_currencies: 'usd',\n              include_24hr_change: true,\n            },\n          }),\n          // Gold price in USD (approximate)\n          axios.get('https://api.coingecko.com/api/v3/simple/price', {\n            params: {\n              ids: 'pax-gold',\n              vs_currencies: 'usd',\n            },\n          })\n        ]);\n\n        const btcData = btcResponse.data.bitcoin;\n        const ethData = ethResponse.data.ethereum;\n        const goldData = goldResponse.data['pax-gold'];\n        \n        // Calculate BTC/ETH price\n        const btcEthPrice = btcData.usd / ethData.usd;\n        const btcEthChange24h = ((btcData.usd_24h_change - ethData.usd_24h_change) / \n          (1 + ethData.usd_24h_change / 100)) || 0;\n\n        // Calculate BTC/Gold price (gold price is per gram, converting to oz)\n        const goldPricePerOz = goldData.usd * 31.1; // 1 oz = 31.1 grams\n        const btcGoldPrice = btcData.usd / goldPricePerOz;\n        \n        // Create updated items\n        const updatedItems = tickerItems.map(item => {\n          switch (item.id) {\n            case 'btc-usd':\n              return { ...item, currentPrice: btcData.usd, priceChange24h: btcData.usd_24h_change };\n            case 'btc-eur':\n              return { ...item, currentPrice: btcData.eur, priceChange24h: btcData.eur_24h_change };\n            case 'btc-eth':\n              return { ...item, currentPrice: btcEthPrice, priceChange24h: btcEthChange24h };\n            case 'btc-gold':\n              return { ...item, currentPrice: btcGoldPrice, priceChange24h: btcData.usd_24h_change };\n            default:\n              return item;\n          }\n        });\n        \n        // Update state\n        updateTickerItems(updatedItems);\n        const newLastUpdated = Date.now();\n        setLastUpdated(newLastUpdated);\n        \n        // Save to cache\n        saveToCache({\n          items: updatedItems,\n          isLoading: false,\n          error: null,\n          lastUpdated: newLastUpdated\n        });\n        \n      } catch (err) {\n        console.error('Error fetching price data:', err);\n        setError('Failed to fetch price data');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    await fetchAndUpdate();\n  }, [tickerItems, updateTickerItems]);\n\n\n\n  useEffect(() => {\n    // Initial fetch\n    fetchBtcPrice();\n\n    // Set up effect for fetching data\n    const intervalId = setInterval(fetchBtcPrice, refreshInterval);\n\n    // Clean up interval on component unmount\n    return () => clearInterval(intervalId);\n  }, [refreshInterval, fetchBtcPrice]);\n\n\n\n  return {\n    items: tickerItems,\n    isLoading,\n    error,\n    lastUpdated,\n  };\n};\n\nexport default useBtcPrice;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}