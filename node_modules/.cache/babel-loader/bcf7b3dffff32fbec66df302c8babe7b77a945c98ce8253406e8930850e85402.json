{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport axios from 'axios';\nconst CACHE_KEY = 'btc_ticker_data';\nconst RATE_LIMIT_KEY = 'coingecko_rate_limit';\nconst CACHE_DURATION = 2 * 60 * 1000; // 2 minutes (matches refresh interval)\nconst REFRESH_INTERVAL = 2 * 60 * 1000; // 2 minutes (reduced from 1 minute)\nconst RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute window for rate limiting\nconst MAX_RETRIES = 2; // Reduced from 3 to be more conservative\nconst BASE_BACKOFF = 2000; // Start with 2 second backoff\n\n// Enhanced fetch with rate limiting and better retry logic\nconst fetchWithRetry = async (url, options, retries = MAX_RETRIES, backoff = BASE_BACKOFF) => {\n  // Check rate limits before making a request\n  const now = Date.now();\n  const rateLimitData = localStorage.getItem(RATE_LIMIT_KEY);\n  if (rateLimitData) {\n    const {\n      timestamp,\n      count\n    } = JSON.parse(rateLimitData);\n    // Reset count if we're in a new rate limit window\n    if (now - timestamp > RATE_LIMIT_WINDOW) {\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n        timestamp: now,\n        count: 1\n      }));\n    } else if (count >= 10) {\n      // Conservative limit (10 calls per minute)\n      // If we've hit the rate limit, wait until the next window\n      const timeToWait = timestamp + RATE_LIMIT_WINDOW - now;\n      console.log(`Rate limit reached. Waiting ${Math.ceil(timeToWait / 1000)} seconds...`);\n      await new Promise(resolve => setTimeout(resolve, timeToWait));\n      // Reset the counter after waiting\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n        timestamp: Date.now(),\n        count: 1\n      }));\n    } else {\n      // Increment the counter\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n        timestamp,\n        count: count + 1\n      }));\n    }\n  } else {\n    // Initialize rate limit tracking\n    localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({\n      timestamp: now,\n      count: 1\n    }));\n  }\n  try {\n    const response = await axios.get(url, {\n      ...options,\n      timeout: 10000,\n      // Increased timeout\n      headers: {\n        'Accept': 'application/json',\n        'Accept-Encoding': 'gzip,deflate,compress'\n      }\n    });\n\n    // If we get a 429 (Too Many Requests), handle it\n    if (response.status === 429) {\n      const retryAfter = parseInt(response.headers['retry-after'] || '5', 10) * 1000;\n      console.log(`Rate limited. Retrying after ${retryAfter}ms...`);\n      await new Promise(resolve => setTimeout(resolve, retryAfter));\n      return fetchWithRetry(url, options, retries, backoff * 2);\n    }\n    return response;\n  } catch (error) {\n    if (retries > 0) {\n      // Use exponential backoff with jitter\n      const jitter = Math.random() * 1000;\n      const delay = backoff + jitter;\n      console.log(`Attempt ${MAX_RETRIES - retries + 1} failed. Retrying in ${Math.round(delay / 1000)}s...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return fetchWithRetry(url, options, retries - 1, Math.min(backoff * 2, 30000)); // Cap at 30s\n    }\n    console.error('Max retries reached:', error.message);\n    throw error;\n  }\n};\nconst useBtcPrice = () => {\n  _s();\n  const [tickerItems, setTickerItems] = useState([{\n    id: 'btc-usd',\n    label: 'BTC/USD',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '$'\n  }, {\n    id: 'btc-eur',\n    label: 'BTC/EUR',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '€'\n  }, {\n    id: 'btc-eth',\n    label: 'BTC/ETH',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: 'Ξ'\n  }, {\n    id: 'gold-usd',\n    label: 'Gold (oz)/USD',\n    currentPrice: null,\n    priceChange24h: null,\n    currencySymbol: '$'\n  }]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [lastUpdated, setLastUpdated] = useState(null);\n  const isMounted = useRef(true);\n  const getCachedData = () => {\n    const cached = localStorage.getItem(CACHE_KEY);\n    if (!cached) return null;\n    try {\n      const parsed = JSON.parse(cached);\n      if (Date.now() - parsed.lastUpdated < CACHE_DURATION) {\n        return parsed;\n      }\n    } catch (e) {\n      console.error('Error parsing cached data:', e);\n    }\n    return null;\n  };\n  const saveToCache = useCallback(items => {\n    try {\n      const dataToCache = {\n        items,\n        lastUpdated: Date.now()\n      };\n      localStorage.setItem(CACHE_KEY, JSON.stringify(dataToCache));\n    } catch (e) {\n      console.error('Error saving to cache:', e);\n    }\n  }, []);\n  const updateTickerItems = useCallback(newItems => {\n    setTickerItems(prevItems => prevItems.map(item => {\n      const updatedItem = newItems.find(newItem => newItem.id === item.id);\n      return updatedItem ? {\n        ...item,\n        ...updatedItem\n      } : item;\n    }));\n  }, []);\n  const fetchBtcPrice = useCallback(async () => {\n    if (!isMounted.current) return;\n\n    // Don't make a new request if we're already loading\n    if (isLoading) return;\n    try {\n      const cachedData = getCachedData();\n      if (cachedData) {\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n        setIsLoading(false);\n        // Only use cache if it's less than 5 minutes old\n        if (Date.now() - cachedData.lastUpdated < 300000) {\n          // Continue to fetch fresh data in background\n        } else {\n          return; // Skip the API call if we have fresh cache\n        }\n      }\n      setIsLoading(true);\n      setError(null);\n\n      // First try with pax-gold, fallback to gold if that fails\n      let response;\n      try {\n        response = await fetchWithRetry('https://api.coingecko.com/api/v3/coins/markets', {\n          params: {\n            vs_currency: 'usd',\n            ids: 'bitcoin,ethereum,pax-gold',\n            price_change_percentage: '24h'\n          }\n        });\n      } catch (err) {\n        console.log('Failed to fetch pax-gold, trying gold...');\n        response = await fetchWithRetry('https://api.coingecko.com/api/v3/coins/markets', {\n          params: {\n            vs_currency: 'usd',\n            ids: 'bitcoin,ethereum,gold',\n            price_change_percentage: '24h'\n          }\n        });\n      }\n      const data = response.data.reduce((acc, coin) => {\n        acc[coin.id] = coin;\n        return acc;\n      }, {});\n      const btcData = data.bitcoin;\n      const ethData = data.ethereum;\n      const goldData = data['pax-gold'] || data.gold;\n      if (!btcData || !ethData || !goldData) {\n        console.error('Incomplete data received from API:', {\n          btcData: !!btcData,\n          ethData: !!ethData,\n          goldData: !!goldData\n        });\n        throw new Error('Incomplete data received from API');\n      }\n      const btcEthPrice = btcData.current_price / ethData.current_price;\n      const btcEthChange24h = (btcData.price_change_percentage_24h - ethData.price_change_percentage_24h) / (1 + ethData.price_change_percentage_24h / 100) || 0;\n\n      // Gold price per ounce in USD (pax-gold is 1:1 with gold price, but we need to check the actual value)\n      // The CoinGecko API returns price per token, and pax-gold is 1 token = 1 troy ounce\n      const goldPricePerOz = goldData.current_price;\n      const updatedItems = [{\n        id: 'btc-usd',\n        label: 'BTC/USD',\n        currentPrice: btcData.current_price,\n        priceChange24h: btcData.price_change_percentage_24h,\n        currencySymbol: '$'\n      }, {\n        id: 'btc-eur',\n        label: 'BTC/EUR',\n        currentPrice: btcData.current_price * 0.9,\n        priceChange24h: btcData.price_change_percentage_24h,\n        currencySymbol: '€'\n      }, {\n        id: 'btc-eth',\n        label: 'BTC/ETH',\n        currentPrice: btcEthPrice,\n        priceChange24h: btcEthChange24h,\n        currencySymbol: 'Ξ'\n      }, {\n        id: 'gold-usd',\n        label: 'Gold (oz)/USD',\n        currentPrice: goldPricePerOz,\n        priceChange24h: goldData.price_change_percentage_24h,\n        currencySymbol: '$'\n      }];\n      updateTickerItems(updatedItems);\n      setLastUpdated(Date.now());\n      saveToCache(updatedItems);\n    } catch (err) {\n      console.error('Error fetching price data:', err);\n      setError('Failed to fetch live data. Using cached data if available.');\n      const cachedData = getCachedData();\n      if (cachedData) {\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n      }\n    } finally {\n      if (isMounted.current) {\n        setIsLoading(false);\n      }\n    }\n  }, [saveToCache, updateTickerItems]);\n  useEffect(() => {\n    isMounted.current = true;\n    fetchBtcPrice();\n    const intervalId = setInterval(fetchBtcPrice, REFRESH_INTERVAL);\n    return () => {\n      isMounted.current = false;\n      clearInterval(intervalId);\n    };\n  }, [fetchBtcPrice]);\n  return {\n    items: tickerItems,\n    isLoading,\n    error,\n    lastUpdated,\n    refresh: fetchBtcPrice\n  };\n};\n_s(useBtcPrice, \"sGNDd3pnV81GmJP/2uRQ7KSY8vk=\");\nexport default useBtcPrice;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","axios","CACHE_KEY","RATE_LIMIT_KEY","CACHE_DURATION","REFRESH_INTERVAL","RATE_LIMIT_WINDOW","MAX_RETRIES","BASE_BACKOFF","fetchWithRetry","url","options","retries","backoff","now","Date","rateLimitData","localStorage","getItem","timestamp","count","JSON","parse","setItem","stringify","timeToWait","console","log","Math","ceil","Promise","resolve","setTimeout","response","get","timeout","headers","status","retryAfter","parseInt","error","jitter","random","delay","round","min","message","useBtcPrice","_s","tickerItems","setTickerItems","id","label","currentPrice","priceChange24h","currencySymbol","isLoading","setIsLoading","setError","lastUpdated","setLastUpdated","isMounted","getCachedData","cached","parsed","e","saveToCache","items","dataToCache","updateTickerItems","newItems","prevItems","map","item","updatedItem","find","newItem","fetchBtcPrice","current","cachedData","params","vs_currency","ids","price_change_percentage","err","data","reduce","acc","coin","btcData","bitcoin","ethData","ethereum","goldData","gold","Error","btcEthPrice","current_price","btcEthChange24h","price_change_percentage_24h","goldPricePerOz","updatedItems","intervalId","setInterval","clearInterval","refresh"],"sources":["/Users/ocean/code/paucotan/personal_projects/btc-price-diff/src/components/LiveBtcPrice/useBtcPrice.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport axios from 'axios';\n\ninterface TickerItem {\n  id: string;\n  label: string;\n  currentPrice: number | null;\n  priceChange24h: number | null;\n  currencySymbol: string;\n}\n\ninterface CachedData {\n  items: TickerItem[];\n  lastUpdated: number;\n}\n\nconst CACHE_KEY = 'btc_ticker_data';\nconst RATE_LIMIT_KEY = 'coingecko_rate_limit';\nconst CACHE_DURATION = 2 * 60 * 1000; // 2 minutes (matches refresh interval)\nconst REFRESH_INTERVAL = 2 * 60 * 1000; // 2 minutes (reduced from 1 minute)\nconst RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute window for rate limiting\nconst MAX_RETRIES = 2; // Reduced from 3 to be more conservative\nconst BASE_BACKOFF = 2000; // Start with 2 second backoff\n\n// Enhanced fetch with rate limiting and better retry logic\nconst fetchWithRetry = async (\n  url: string, \n  options: Record<string, unknown>,\n  retries = MAX_RETRIES,\n  backoff = BASE_BACKOFF\n): Promise<any> => {\n  // Check rate limits before making a request\n  const now = Date.now();\n  const rateLimitData = localStorage.getItem(RATE_LIMIT_KEY);\n  \n  if (rateLimitData) {\n    const { timestamp, count } = JSON.parse(rateLimitData);\n    // Reset count if we're in a new rate limit window\n    if (now - timestamp > RATE_LIMIT_WINDOW) {\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp: now, count: 1 }));\n    } else if (count >= 10) { // Conservative limit (10 calls per minute)\n      // If we've hit the rate limit, wait until the next window\n      const timeToWait = (timestamp + RATE_LIMIT_WINDOW) - now;\n      console.log(`Rate limit reached. Waiting ${Math.ceil(timeToWait/1000)} seconds...`);\n      await new Promise(resolve => setTimeout(resolve, timeToWait));\n      // Reset the counter after waiting\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp: Date.now(), count: 1 }));\n    } else {\n      // Increment the counter\n      localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp, count: count + 1 }));\n    }\n  } else {\n    // Initialize rate limit tracking\n    localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify({ timestamp: now, count: 1 }));\n  }\n\n  try {\n    const response = await axios.get(url, { \n      ...options, \n      timeout: 10000, // Increased timeout\n      headers: {\n        'Accept': 'application/json',\n        'Accept-Encoding': 'gzip,deflate,compress',\n      }\n    });\n    \n    // If we get a 429 (Too Many Requests), handle it\n    if (response.status === 429) {\n      const retryAfter = parseInt(response.headers['retry-after'] || '5', 10) * 1000;\n      console.log(`Rate limited. Retrying after ${retryAfter}ms...`);\n      await new Promise(resolve => setTimeout(resolve, retryAfter));\n      return fetchWithRetry(url, options, retries, backoff * 2);\n    }\n    \n    return response;\n  } catch (error: any) {\n    if (retries > 0) {\n      // Use exponential backoff with jitter\n      const jitter = Math.random() * 1000;\n      const delay = backoff + jitter;\n      console.log(`Attempt ${MAX_RETRIES - retries + 1} failed. Retrying in ${Math.round(delay/1000)}s...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return fetchWithRetry(url, options, retries - 1, Math.min(backoff * 2, 30000)); // Cap at 30s\n    }\n    console.error('Max retries reached:', error.message);\n    throw error;\n  }\n};\n\nconst useBtcPrice = () => {\n  const [tickerItems, setTickerItems] = useState<TickerItem[]>([\n    { id: 'btc-usd', label: 'BTC/USD', currentPrice: null, priceChange24h: null, currencySymbol: '$' },\n    { id: 'btc-eur', label: 'BTC/EUR', currentPrice: null, priceChange24h: null, currencySymbol: '€' },\n    { id: 'btc-eth', label: 'BTC/ETH', currentPrice: null, priceChange24h: null, currencySymbol: 'Ξ' },\n    { id: 'gold-usd', label: 'Gold (oz)/USD', currentPrice: null, priceChange24h: null, currencySymbol: '$' },\n  ]);\n  \n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [lastUpdated, setLastUpdated] = useState<number | null>(null);\n  const isMounted = useRef(true);\n\n  const getCachedData = (): CachedData | null => {\n    const cached = localStorage.getItem(CACHE_KEY);\n    if (!cached) return null;\n    \n    try {\n      const parsed = JSON.parse(cached);\n      if (Date.now() - parsed.lastUpdated < CACHE_DURATION) {\n        return parsed;\n      }\n    } catch (e) {\n      console.error('Error parsing cached data:', e);\n    }\n    return null;\n  };\n\n  const saveToCache = useCallback((items: TickerItem[]) => {\n    try {\n      const dataToCache = {\n        items,\n        lastUpdated: Date.now(),\n      };\n      localStorage.setItem(CACHE_KEY, JSON.stringify(dataToCache));\n    } catch (e) {\n      console.error('Error saving to cache:', e);\n    }\n  }, []);\n\n  const updateTickerItems = useCallback((newItems: TickerItem[]) => {\n    setTickerItems(prevItems => \n      prevItems.map(item => {\n        const updatedItem = newItems.find(newItem => newItem.id === item.id);\n        return updatedItem ? { ...item, ...updatedItem } : item;\n      })\n    );\n  }, []);\n\n  const fetchBtcPrice = useCallback(async () => {\n    if (!isMounted.current) return;\n    \n    // Don't make a new request if we're already loading\n    if (isLoading) return;\n    \n    try {\n      const cachedData = getCachedData();\n      if (cachedData) {\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n        setIsLoading(false);\n        // Only use cache if it's less than 5 minutes old\n        if (Date.now() - cachedData.lastUpdated < 300000) {\n          // Continue to fetch fresh data in background\n        } else {\n          return; // Skip the API call if we have fresh cache\n        }\n      }\n      \n      setIsLoading(true);\n      setError(null);\n      \n      // First try with pax-gold, fallback to gold if that fails\n      let response;\n      try {\n        response = await fetchWithRetry(\n          'https://api.coingecko.com/api/v3/coins/markets',\n          {\n            params: {\n              vs_currency: 'usd',\n              ids: 'bitcoin,ethereum,pax-gold',\n              price_change_percentage: '24h',\n            },\n          }\n        );\n      } catch (err) {\n        console.log('Failed to fetch pax-gold, trying gold...');\n        response = await fetchWithRetry(\n          'https://api.coingecko.com/api/v3/coins/markets',\n          {\n            params: {\n              vs_currency: 'usd',\n              ids: 'bitcoin,ethereum,gold',\n              price_change_percentage: '24h',\n            },\n          }\n        );\n      }\n      \n      const data = response.data.reduce((acc: any, coin: any) => {\n        acc[coin.id] = coin;\n        return acc;\n      }, {});\n      \n      const btcData = data.bitcoin;\n      const ethData = data.ethereum;\n      const goldData = data['pax-gold'] || data.gold;\n      \n      if (!btcData || !ethData || !goldData) {\n        console.error('Incomplete data received from API:', { btcData: !!btcData, ethData: !!ethData, goldData: !!goldData });\n        throw new Error('Incomplete data received from API');\n      }\n      \n      const btcEthPrice = btcData.current_price / ethData.current_price;\n      const btcEthChange24h = ((btcData.price_change_percentage_24h - ethData.price_change_percentage_24h) / \n        (1 + ethData.price_change_percentage_24h / 100)) || 0;\n      \n      // Gold price per ounce in USD (pax-gold is 1:1 with gold price, but we need to check the actual value)\n      // The CoinGecko API returns price per token, and pax-gold is 1 token = 1 troy ounce\n      const goldPricePerOz = goldData.current_price;\n      \n      const updatedItems: TickerItem[] = [\n        { \n          id: 'btc-usd', \n          label: 'BTC/USD', \n          currentPrice: btcData.current_price, \n          priceChange24h: btcData.price_change_percentage_24h, \n          currencySymbol: '$' \n        },\n        { \n          id: 'btc-eur', \n          label: 'BTC/EUR', \n          currentPrice: btcData.current_price * 0.9,\n          priceChange24h: btcData.price_change_percentage_24h, \n          currencySymbol: '€' \n        },\n        { \n          id: 'btc-eth', \n          label: 'BTC/ETH', \n          currentPrice: btcEthPrice, \n          priceChange24h: btcEthChange24h, \n          currencySymbol: 'Ξ' \n        },\n        { \n          id: 'gold-usd', \n          label: 'Gold (oz)/USD', \n          currentPrice: goldPricePerOz, \n          priceChange24h: goldData.price_change_percentage_24h, \n          currencySymbol: '$' \n        },\n      ];\n      \n      updateTickerItems(updatedItems);\n      setLastUpdated(Date.now());\n      saveToCache(updatedItems);\n      \n    } catch (err) {\n      console.error('Error fetching price data:', err);\n      setError('Failed to fetch live data. Using cached data if available.');\n      const cachedData = getCachedData();\n      if (cachedData) {\n        updateTickerItems(cachedData.items);\n        setLastUpdated(cachedData.lastUpdated);\n      }\n    } finally {\n      if (isMounted.current) {\n        setIsLoading(false);\n      }\n    }\n  }, [saveToCache, updateTickerItems]);\n\n  useEffect(() => {\n    isMounted.current = true;\n    fetchBtcPrice();\n    \n    const intervalId = setInterval(fetchBtcPrice, REFRESH_INTERVAL);\n    \n    return () => {\n      isMounted.current = false;\n      clearInterval(intervalId);\n    };\n  }, [fetchBtcPrice]);\n\n  return {\n    items: tickerItems,\n    isLoading,\n    error,\n    lastUpdated,\n    refresh: fetchBtcPrice,\n  };\n};\n\nexport default useBtcPrice;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}